#!/usr/bin/node
// Code based on https://gist.github.com/martinsik/2031681

"use strict";

var config=require("./conf.js");
var clients={};

var webSocketServer=require('websocket').server;
var http=require('http');
var fs=require('fs');

var sqlite3=require('sqlite3');
var db=new sqlite3.Database(config.database, function(error) {
  if(error) {
    console.log("Can't open SQLITE database: "+error.message);
    process.exit(1);
  }

  db.exec("select * from mass_event", function(error) {
    if(error) {
      console.log("Database seems to be empty -> initializing");
      fs.readFile("./init.sql", "utf8", function(error, text) {
	if(error) {
	  console.log("Error reading init.sql");
	  process.exit(1);
	}

	db.exec(text, function(error) {
	  if(error) {
	    console.log("Error initializing database: "+error.message);
	    process.exit(1);
	  }
	});
      });
    }
  });
});

var hooks=require('./modules/base/modules/hooks/hooks.js');
var test=require('./server-test.js');
test.register({hooks: hooks});
hooks.call("server_init");

var server=http.createServer(function(request, response) {
});
server.listen(config.port, function() {
  console.log((new Date())+" HTTP server listening on port "+config.port);
});

var wsServer=new webSocketServer({
  httpServer: server
});

var uniq_ids={};
function uniq_id() {
  var ret="";

  do {
    for(var i=0; i<4; i++)
      ret+=String.fromCharCode(Math.floor(Math.random()*26)+65);
  } while(uniq_ids[i]);

  uniq_ids[ret]=true;

  return ret;
}

function client(id, connection) {
  this.id=id;
  this.connection=connection;

  clients[id]=this;
  this.connection.sendUTF("Welcome");
  console.log((new Date())+" Connection "+id+" accepted");

  this.connection.on('message', function(message) {
    var param=null;

    if(message.type==="utf8") {
      console.log((new Date())+" Received message from "+this.id);
      try {
	param=JSON.parse(message.utf8Data);
      }
      catch(e) {
      }

      if(param) {
	param.peer_id=this.id;
	var current_client=this;

	db.run("insert into tracker_message (tracker_id, timestamp, type, data) values (?, ?, ?, ?)",
	    [ this.id, param.timestamp, param.type, JSON.stringify(param.data) ], function(error) {
	      if(error) {
		console.log("Error inserting into database: "+error.message);
	      }
	      else {
		param.msg_num=this.lastID;
		current_client.db_callback_message(param, this);
	      }
	    });
      }
    }

    if(!param) {
      console.log((new Date())+" Illegal message received: ");
      console.log(message);
    }
  }.bind(this));

  this.connection.on('close', function() {
    delete(clients[this.id]);
    console.log((new Date())+" Connection "+this.id+" closed");
  }.bind(this));
}

client.prototype.db_callback_message=function(param, row) {
  hooks.call("message_received", param, this);

  console.log(param);

  for(var i in clients) {
    if(i!=this.id)
      clients[i].send(param);
    else
      clients[i].send({
	ack: param.timestamp,
	msg_num: param.msg_num,
	data: param.data   // TODO: check for changed data
      });
  }
}

client.prototype.send=function(data) {
  this.connection.sendUTF(JSON.stringify(data));
}

wsServer.on('request', function(request) {
  console.log((new Date())+" Connection from "+request.origin);

  var connection=request.accept(null, request.origin);
  var id=uniq_id();
  new client(id, connection);
});
